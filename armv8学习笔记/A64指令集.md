***A64指令集与armv9指令集相差不大，对于上学期已掌握的知识点不再赘述***
# A64介绍
1. 运行在aarch64状态下，在aarch32状态运行A32或T32。
2. 指令宽度为32位。
3. 可以处理64位的寄存器和数据，并可以使用64位的指针来访问内存。
4. 寄存器和指令助记符可以全是小写或者大写
5. //可用于汇编代码的注释
# 与A32区别
## 加载与存储指令的区别
1. A64多支持了一种不可扩展模式的加载和存储指令LDUR和STUR，即偏移量只能按照字节来扩展，还可以是正数或者是负数（A32按照数据大小来扩展并且只能是正数。），取值范围为-256~255。  
   格式：STUR/LDUR \<Xt> [<Xn>,#imme]  
   imme的范围为-256~255
2. 多字节加载和存储指令中，A64不使用LDM和STM，使用LDP和STP  
   格式：LDP/STP \<X1>,\<X2> [Xn|SP{,#imm}]  
   imm的取值范围为-512~504，且必须为8的整数倍
3. armv8提供独占内存访问的指令（LDXR,STXR,LDXP,STXP)，LDXR指令尝试在内存总线中申请一个独占访存的锁，，然后访问一个内存地址。STXR往刚才LDXR指令已经申请的内存地址中写入新内容，常用来完成一些同步操作
4. armv8提供一组包含了屏蔽原语的新的加载和存储指令（LDAR，STLR）  
- ldar指令后面的读写内存指令必须在其之后，stlr之前执行
5. 非特权访问级别的加载和存储指令，用于在EL0下进行内存访问，在LD和ST后加上T如：
   ldtrsw 加载4字节的有符号数。   
   **注意，A64中加载、存储指令后的S后缀不表示影响标志位，而是表示是否当作有符号数处理,而数据处理指令，如add，sub后的s后缀表示影响标志位**
## mov指令的区别
1. mov指令能传输的立即数只能为16位，或者由16位数左移16/32/48位  
mov x0, #0x1abdf 中，立即数非法。
2. mov指令无法对数据进行移位操作再传输，此时应使用MOVZ指令  
   ```movz xt,#imm16, lsl #shift```
3. ```mov x1,#0xffff0000ffff```会转化为```orr x1,xzr,#0xffff0000ffff```这里的立即数必须是有效的位图立即数
4. 0xffff000ffffffff既不是有效的位图立即数，也不可由16位数左移得到。可以使用LDR伪指令  
   ```#define H 0xffff000ffffffff``` 
   ```ldr x0,= H```  

   有效的位图立即数：
## 数据处理指令
1. 依然有与A32相同的条件操作码
2. add和sub的立即数为12位，取值范围0~4095，使用立即数加减时，左移的位数只能为12.
3. add与sub进行寄存器加减时，可以选择对第二个源操作数进行扩展计算  
   格式如下：```add/sub xd,xs,xt,lsl/UXTB/SXTB...```  
   - UXTB：对低8位的数据进行无符号扩展（除了低八位，其他位清零）
   - UXTH: 对低16位的数据进行无符号扩展（除了低16位，其他位清零）
   - UXTW：对字进行无符号扩展
   - 以上第一个字母改为S，表示对数据进行有符号扩展，例如对0x108a低8位进行有符号数扩展是0xffffffffffffff8a
   - 具体示例P59
   - 移位时，移位的位数为0~63？
4. CLZ指令计算数据首个1之前有多少个零，送入相对应的寄存器
   ```mov x1,0xfffffffffffffff```
   ```clz x0,x1``` x0  = 3
5. BFI位段插入操作指令：BFI xd,xs,#lsb,#width，将xs寄存器中的bit[0,wtdth - 1]替换xd寄存器中[lsp, lsp + width - 1]
6. UBFX位段提取操作：UBFX xd,xs,#lsp,#width 将xs中[lsp lsp + width - 1]的位提取出来送入xd。SBFX提取的位域会进行符号扩展。
## 比较指令
1. CMN：负数比较指令，减去后一个操作数的负数。
2. CSEL指令：CSEL xd，xn，xm，cond。判断cond是否为真，如果为真，则返回xn，否则返回xm，需要与cmp或者是cmn指令配合
3. CSET指令：CSET xd，cond。当条件为真时将xd设为1，否则设为0。
4. CSINC指令：CSINC xd,xn,xm,cond。cond为真时，返回xn，否则返回xm + 1。
# 跳转指令
1. b label（跳转），bl label（带返回地跳转），br（从寄存器中获取跳转地址），blr（带返回地跳转到寄存器指定的地址）
2. 返回指令：ret：从子函数返回，返回地址再LR中  
   
   ERET ：从异常模式返回，将spsr的内容恢复到PSTATE，并从ELR中获得返回地址。
3. 比较跳转指令：  
   - CBZ xt，label：如果xt为0，跳转到label处。
   - CBNZ xt，label：xt不为0，跳转到label处。
   - TBZ rt，#imm，label：rt的imm位为0，跳转到label处。
   - TBNZ rt，#imm，label：rt的imm位不为0，跳转到label处。

## 异常处理指令
1. SVC #imm：自陷入操作系统中，通常进入EL1
2. HVC #imm：主机操作系统通过HVC自陷到虚拟管理程序，通常进入EL2
3. SMC #imm：操作系统或虚拟机管理程序通过SMC自陷到安全监管程序  
   imm范围为0~65535，一般用于调试，而使用通用寄存器传递系统调用号。
## 内存屏障指令
1. DMB：在访问新的存储器前，所有的存储器访问均已完成
2. DSB：下一个指令执行前，所有存储器访问均已完成。
3. ISB：清空流水线，在下一个指令执行前，所有的指令已执行完毕


   