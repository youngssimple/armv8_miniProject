# 术语与解释
AArch64: armv8体系结构下，64位上下文状态。 

AAPCS64：procedure call standard for arm 64-bit architecture。AArch64下的过程调用标准。 
 
ABI：application binary interface 应用程序二进制接口。它规定了：  
1. 一个可执行程序想在一个特定的执行环境中执行应该满足的规范。
2. 独立生成的可重定位文件为了能够静态链接及可执行应该满足的规范。

A32：arm32位定长指令集  
A64：arm64位指令集（处于aarch64状态下可用）  
T32：提供16位和32位指令集支持

# armv8处理器结构
## 基础知识
1. armv8有两种执行状态分别是aarch64和aarch32。在64位上下文时，armv8运行A64指令集。在32位上下文运行A32指令集和T32指令集。
2. aarch64状态的4个异常等级（exception level）确定了当前运行的特权级别。 
   
典型的异常等级使用如下，

EL0：用户特权，用于运行普通用户程序

EL1：系统特权，通常运行操作系统内核

EL2：运行虚拟化扩展的虚拟机监控程序（Hypervisor）

EL3：运行安全世界中的安全监控器（Secure Monitor）
说明1：通常情况下，每层软件都运行在一个异常等级中。但是有个例外，就是在操作系统内核中实现的hypervisor（e.g. KVM），他运行在EL1和EL2中

说明2：在基于ARMv8体系结构的处理器实现中，EL0和EL1是必须实现的，而EL2和EL3的实现是可选的。同时，异常等级的实现也不需要是连续的，例如可以实现EL0、EL1和EL3

# 数据类型和对齐方式
![数据对齐方式](./img/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png)
## 半精度浮点数
有两种支持的格式：
- 使用IEEE 754-2008标准，适合表示低精度的数，共有16位，第一位为符号位，后5位为指数位，最后10位为尾数位。指数位偏移值为15。有如下情况：
1. 尾数位为0，指数位全为1，表示无穷大，符号位为1时表示负无穷大。
2. 尾数位不全为0，指数位全为1，不表示一个数。
- Arm Alternative 格式，提供额外的范围但没有 NaN 或无穷大。
## 短矢量
1. 短矢量是由一个基本的整型或浮点型（比如 int型）的几个实例所组成的机器类型，它的类型是基本整形或浮点型，看它由什么组成。
2. 短矢量的大小一般为双字或四字，它的内存使用必须是紧凑的，例如，一个双字（8字节）的短矢量可以由8个字节类型实例组成，也可以由4个半字类型的实例组成，只要所占空间总大小为8字节就行，对于4字短矢量，也一样。其对齐方式按双字或四字对齐。
3. 短矢量中的元素有按序的编号，编号小的元素占据低位。需要注意，这里的低位是短矢量中的地位，例如，在小端系统中，短矢量中低编号的元素会占据低地址存储单元，而在大端系统中，短矢量中的低编号元素会占据高地址单元。
4. 短矢量的调用是不透明的，使用LDR或STR指令进行加载或存储。
## 指针
1. armv8中的每个指针占据8个字节，64位，其每一位都有效，指向为空时，每一位都为0。
2. 使用标记寻址时，标记是指针值的一部分，指定指针算法。
# 字节序
从软件的角度来看，内存是一个字节数组，每个字节都是可寻址的。
此 ABI 支持由底层硬件实现的两种内存视图：大端和小端。
# 复合类型
复合类型是一个或多个基本数据类型的集合，在过程调用级别作为单个实体处理。复合类型可以是以下任何一种：

        1. 聚合，其中成员在内存中按顺序排列

        2. 联合，其中每个成员具有相同的地址

        3. 数组，它是某种其他类型的重复序列（其基类型）。

定义是递归的；也就是说，每个类型都可以包含一个复合类型作为成员。
## 聚合
1.  聚合的对齐应按照其最大的对齐元素。
2.  一个聚合的大小应该为最大元素线性且足以容纳所有它所有成员的最小倍数。
## 联合
1. 按最大元素对齐
2. 足以容纳最大成员的对齐的最小倍数
## 数组
数组的对齐就是按照组成其的基本数据类型对齐，
大小就是按照基本数据大小乘以元素个数。
## 位域
聚合内的成员可以划分位域，让某成员对齐后未使用的内存部分给后续满足大小的成员使用。```struct i{int i; double j;int h};```大小为16，对齐为8；
```int i:8```定义一个8位的整型
## 同构聚合
成员的数据类型相同的聚合。包括HFA（浮点同构聚合），HVA（短矢量同构聚合）等
# armv8寄存器
armv8有两组寄存器，一组通用寄存器用于整型加工和指针运算，一组单指令多数据指令和浮点寄存器组。
## 通用寄存器
1. aarch64状态下有31个64位的通用寄存器，分别是X0-X30，而在aarch32状态下支持16个32位的通用寄存器。
2. 在aarch64位状态下，用X0，X1等表示64位的寄存器，而用W0，W1，表示寄存器低32位的数据，比如W3表示寄存器X3的低32位数据。
3. aarch64状态下，
- X0-X7用于传递参数和结果；  
- X8用于间接结果寄存器；
- X9-X15是暂时寄存器，理论上遵循调用者保存原理；
- X16和X17是IP0和IP1，内部过程调用寄存器，常用于动态链接中的plt寻址；
- X18（PR）是平台寄存器，无需要时可用作临时寄存器；
- X19-X28 遵循被调用者保存策略。
- X29：FP栈帧寄存器
- X30：LR链接寄存器
![aarch64寄存器调用](./img/aarch64%E5%AF%84%E5%AD%98%E5%99%A8%E8%B0%83%E7%94%A8.png)
函数A调用了函数B，寄存器rbx在函数B中被修改了，逻辑上%rbx内容在调用函数B的前后应该保持一致，
解决这个问题有两个策略，
(1)在函数A在调用函数B之前提前保存寄存器%rbx的内容，执行完函数B之后再恢复%rbx的内容，这个策略就称为调用者保存；
(2)函数B在使用寄存器%rbx，先保存寄存器%rbx的值，在函数B返回之前，要恢复寄存器%rbx原来存储的内容，这种策略被称之为被调用者保存。
## SIMD（单指令多数据）和浮点类型寄存器
armv8在aarch64状态下还有32个128位用于浮点计算和SIMD的向量寄存器V0-V31，这128位也可以拆开使用如：
1. 每个128-bit向量寄存器可以当做：

包含 2 个 64-bit 元素的向量寄存器来用，表达形式是 vn.2d；
包含 4 个 32-bit 元素的向量寄存器来用，表达形式是 vn.4s；
包含 8 个 16-bit 元素的向量寄存器来用，表达形式是 vn.8h；
包含 16 个 8-bit 元素的向量寄存器来用，表达形式是 vn.16b；
注：q：128  d：64 s：32 h：16 b：8
2. 或者每个向量寄存器也可以只用低 64-bit：

1 个 64-bit 元素的向量寄存器来用，表达形式是 vn.1d；
2 个 32-bit 元素的向量寄存器来用，表达形式是 vn.2s；
4 个 16-bit 元素的向量寄存器来用，表达形式是 vn.4h；
8 个 8-bit 元素的向量寄存器来用，表达形式是 vn.8b；
我看网上还有一种说法是：
每个寄存器根据实际使用长度，命名会有所不同。具体表示如下：

A 128-bit register named Q0 to Q31.

A 64-bit register named D0 to D31.

A 32-bit register named S0 to S31.

A 16-bit register named H0 to H31.

An 8-bit register named B0 to B31.

A 128-bit vector of elements.

A 64-bit vector of elements.

3. V0-V7是向子例程传递参数和存储返回值的寄存器，也可以用于存储一个调用过程中的间接值。
4. V8-V15的低64位遵循被调用者保存策略，其他寄存器，包括V8-V15的高64位，需要由调用者主动调用。
5. FPCR是一个用于保存浮点单元累计异常位的状态寄存器，用于控制浮点单元的行为。
8-12位是异常控制位，22-23是舍入模式位，24是清零位。其余所有位都是被保留且不可被更改的。
## 特殊寄存器
除了31个通用寄存器，还有几个特殊寄存器。

没有寄存器叫X31或W31。许多指令被编码为数字31来表示zero寄存器（ZR（WZR/XZR））。还有一个受限的指令组，其中一个或多个参数被编码，使数字31表示堆栈指针(SP)。

当访问zero寄存器，所有的写入都被忽略，所有的读取都返回0，AArch32执行状态使用WZR指令访问zero寄存器，AArch64执行状态使用XZR访问zero寄存器。AArch32执行状态使用WSP访问当前栈指针寄存器，AArch64执行状态使用SP访问当前栈指针寄存器。AArch32执行状态和AArch64执行状态使用PC访问程序计数寄存器。注意：64位形式的SP寄存器不使用X前缀。


在ARMv8架构中，当处于AArch64为执行状态时，异常的返回状态保留在以下每个异常级别的专用寄存器中：

Exception Link Register (ELR)
Saved Processor State Register (SPSR)
每个异常级别中都有专用的SP寄存器，退出该异常级别时不用保存。


1. Zero register(WZR,XZR)
将Zero寄存器当作源寄存器读取时，会得到0值，将Zero寄存器当作目的寄存器写入时，写入的值被丢弃。可以在大多数指令(但不是所有指令)中使用zero寄存器。

2. Stack pointer(WSP,SP)
在ARMv8架构中，每个异常级别都拥有栈指针寄存器，即拥有4个栈指针寄存器。默认情况下，异常级别ELn对应的栈指针寄存器为SP_ELn，如EL0对应SP_EL0，EL1对应SP_EL1，EL2对应SP_EL2，EL3对应SP_EL3。当处理器的执行状态为AArch64且不处于异常级别EL0，则可以使用与异常级别相关的专用64位堆栈指针（SP_ELn）和与异常级别EL0相关的栈指针寄存器（SP_EL0）。
EL0只能访问SP_EL0栈指针寄存器。
各个异常级别与可使用的栈寄存器对关系如下图所示。软件可以在目标异常级别执行的时候通过更新PSTATE.SP来指向SP_EL0的堆栈指针。t表明使用SP_EL0堆栈指针，h表明使用SP_ELx堆栈指针，t和h后缀基于线程(thread)和处理程序(handler)的首字母。


栈指针寄存器SP不能被大多数指令引用，但可以被一些算数指令引用，如ADD指令，可以读写当前栈指针寄存器以调整函数的栈指针。
ADD SP, SP, #0x10 // Adjust SP to be 0x10 bytes before its current value

3. Program Counter(PC)
早期的ARMv7将通用寄存器R15作为PC寄存器。PC使一些巧妙的编程技巧成为可能，但它给编译器和复杂流水线的设计带来了困难。ARMv8架构中删除了对PC寄存器的直接访问，这使得返回预测更容易，并简化了ABI规范。PC寄存器不能作为命名寄存器访问，而是通过确定的指令隐含的访问，如相对PC的加载和产生地址。PC寄存器不能明确的作为数据处理指令或加载指令的目的寄存器。

4. Exception Link Register(ELR)
ELR寄存器保存了异常返回地址，ARMv8定义了3个ELR寄存器，分别对应异常级别EL1、EL2、EL3。

5. Saved Process Status Register(SPSR)
当异常发生时，处理器的状态将会被保存到相关的SPSR寄存器中。异常发生后，在处理异常之前，处理器会自动的将PSTATE寄存器的内容保存到SPSR中，异常返回时，会将SPSR保存的处理器状态恢复到PSTATE中。ARMv8定义的SPSR寄存器如下，兼容ARMv7中的SPSR寄存器，只使用低32位。


各个位域定义如下：

N 符号位（N flag）
Z 0标志（Z flag）
C 操作进位（C flag）
V 溢出标志（V flag）
SS 用于软件调试。异常发生的时候，通过设置MDSCR_EL1.SS为1启动单步调试机制
IL 不合法的执行状态（非法异常），保存自PSTATE.IL
D 处理器状态调试掩码。指示是否屏蔽来自观察点、断点和软件步骤调试事件的调试异常
A 软件错误掩码位
I IRQ掩码位
F FIQ掩码位
M[4] 发生异常时处理器的执行状态，0表示AArch64
M[3:0] M[3:2]发生异常的级别；M[1]保留；M[0]根据此选择栈指针寄存器，0表示t，1表示h。
可以通过异常级别的栈指针后缀表明所选的栈指针，M[3:0]可参考下面的图：

在ARMv8架构中，有3个SPSR寄存器，分别为SPSR_EL1、SPSR_EL2、SPSR_EL3。使用那个SPSR寄存器依赖于异常级别。若异常级别为EL1，则使用SPSR_EL1，若异常级别为EL2，则使用SPSR_EL2，若异常级别为EL3，则使用SPSR_EL3。
ELR_ELn和SPSR_ELn寄存器和异常级别相关联，始终保存着低于当前异常级别的处理器状态。

6. Processor state(PSTATE)
AArch64没有和ARMv7 Current Program Status Register(CPSR)寄存器一样的寄存器。在AArch64执行状态中，处理器的状态使用PSTATE描述，但PSTATE不是寄存器，而是处理器状态各个位域的总称。PSTATE的大部分位域和传统CPSR寄存器中的位域相同。PSTATE的位域如下图所示。EL0可以访问PSTATE的N、Z、C、V位域，其他域只能在EL1及更高的异常级别中访问。



在AArch64执行状态中，使用ERET命令从异常中返回，即将SPSR_ELn寄存器中保存的发生异常时的处理器状态恢复到PSTATE中。SPSR_ELn中保存了发生异常时ALU的标志、执行状态、异常级别及处理器branches。处理器从异常返回后的执行地址保存在ELR_ELn中。

7. System registers
在AArch64中，通过MSR和MRS指令访问系统寄存器，以此来控制系统。系统寄存器名称后缀反应了访问该寄存器所需的最低异常级别，如下所示。。

TTBR0_EL1可以访问的异常级别为EL1、EL2、EL3，EL0无法访问
TTBR0_EL2可以访问的异常级别为EL2、EL3，EL0和EL1无法访问
大部分系统寄存器所需的访问异常级别都大于EL1。只有少部分寄存器可以在EL0级别中访问，如Cache Type Register (CTR_EL0)。

